var Trobot = require('trobot'),
    max = new Trobot();

// *******
// HELPERS
// *******

function getPersonFromWeek() {
  function getWeekNumber() {
    var d = new Date();
    d.setHours(0,0,0,0);
    d.setDate(d.getDate()+4-(d.getDay()||7));
    return Math.ceil((((d-new Date(d.getFullYear(),0,1))/8.64e7)+1)/7);
  }

  var peeps = ['Anna','Kicki','C-F'],
      weekNumber = getWeekNumber(),
      index = weekNumber % peeps.length,
      person = peeps[index];

  return person;
}

function readComment(comment, authorUsername, bot) {
  function botInComment() {
    var botUsername = "@" + bot.data.username;
    return new RegExp(botUsername).test(comment);
  }
  var answer = "@" + authorUsername + " ";

  // no @
  if (!/@/g.test(comment)) {
    answer += "Använd @username så får mottagaren en notis om din kommentar via mejl.";
    return answer;
  }
  
  // @max sekreterare
  if (botInComment() && /sekreterare/i.test(comment)) {
    answer += getPersonFromWeek() + " är sekreterare denna veckan.";
    return answer;
  }
  
  // @max [vilka] enhet[er] [finns på] sektion
  if (botInComment() && /enhet/i.test(comment)) {
    var re = /akut|psykos|affektiva|barn|bup|beroende|neuro/i,
        match = comment.match(re),
        section;
    
    if (!match) {
      section = null;
      
    } else {
      var orgMap = {
        "akut": "Akut- och konsultpsykiatri",
        "psykos": "Psykosvård- och rättspsyk vård",
        "affektiva": "Affektiva sjukdomar",
        "barn": "Barn- och ungdomspsykiatri",
        "bup": "Barn- och ungdomspsykiatri",
        "beroende": "Beroende- och neuropsykiatri",
        "neuro": "Beroende- och neuropsykiatri"
      };
      section = orgMap[match[0].toLowerCase()];
    }
    
    var file = require('./psyk.json');
    
    if (!section) {
      answer += 'Letar du efter enheter på psyk? Ange en sektion som akut, psykos, affektiva, barn, bup, beroende eller neuro.';
      return answer;
      
    } else {
      answer += 'Enheter på ' + section + ':\n';
      answer += file[section]
        .map(function(str){
          return str + '\n'
        })
        .join('');
      
      return answer;
    }
  }
  
  // @max [no other match]
  if (botInComment()) {
    answer += "Blip blop";
    return answer;
  }
  return null;
}

// **************
// EVENT HANDLERS
// **************

function replyToComment(data, res) {
  if (data.model.id === this.data.userid) { // only listen for models other than bot
    this.emit('log', 'Model is bot. No reply.');
    res.end();
    return
  }

  var comment = data.action.data.text,
      authorId = data.action.memberCreator.id,
      authorUsername = data.action.memberCreator.username,
      cardId = data.action.data.card.id;

  if (authorId !== this.data.userid) {
    var answer = readComment(comment, authorUsername, this);

    if (answer) {
      this.emit('reply', cardId, answer, res);

    } else {
      this.emit('log', 'Comment for another user. No reply.');
      res.end();
    }

  } else {
    this.emit('log', 'Comment author is bot. No reply.');
    res.end();
  }
}

function longTitle(data, res) {
  var titleLength = data.action.data.card.name.length,
      authorUsername = data.action.memberCreator.username,
      cardId = data.action.data.card.id;

  if (titleLength > 100) {
    var answer = "@" + authorUsername + " Långa titlar är svåra att läsa :( Kanske stoppa en del i beskrivningen ist?";
    this.emit('reply', cardId, answer, res);

  } else {
    this.emit('log', 'Short title. No reply.');
    res.end();
  }
}

function addWebhook(data, res) {
  if (data.model.id !== this.data.userid) { // only listen for the bot model
    this.emit('log', 'Model is not bot. No webhook added.');
    res.end();
    return
  }

  var self = this,
      url = "/1/webhooks",
      payload = {
        description: "Autogenerated webhook for " + data.action.data.board.name,
        callbackURL: self.data.webhookcallbackurldefault,
        idModel: data.action.data.board.id
      };

  self.trello.post(url, payload, function(err, postData){
    if (err) {
      self.emit('error', err, 500, res);
      return
    }

    self.emit('log', payload.description + ' added');
    res.end();
  });
}

function removeWebhook(data, res) {
  if (data.model.id !== this.data.userid) { // only listen for the bot model
    this.emit('log', 'Model is not bot. No webhook removed.');
    res.end();
    return
  }
  
  var self = this,
      idModel = data.action.data.board.id,
      listUrl = '/1/tokens/' + self.trello.token + '/webhooks';

  self.trello.get(listUrl, function(err, list) {
    if (err) {
      self.emit('error', err, 500, res);
      return
    }

    var webhook = list.filter(function(o){
      return o.idModel === idModel;
    })[0];
  
    if (!webhook) {
      self.emit('error', 'No webhook on idModel found. No webhook removed.', 500, res);
      return
    }
  
    var delUrl = "/1/webhooks/" + webhook.id;

    self.trello.del(delUrl, function(err, deletedWebhook){
      if (err) {
        self.emit('error', err, 500, res);
        return
      }

      self.emit('log', webhook.description + ' deleted');
      res.end();
    });
  });
}

// EVENTS

max.on('log', console.log);
max.on('commentCard', replyToComment);
max.on('createCard', longTitle);
max.on('updateCard', longTitle);
max.on('addMemberToBoard', addWebhook);
max.on('removeMemberFromBoard', removeWebhook);

module.exports = max;
